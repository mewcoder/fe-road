# 计算机网络

## 1.TCP 和 UDP 区别

- `TCP` 面向连接，`UDP` 不需要建立连接
- `TCP` 是面向字节流的(可分割)，`UDP` 是面向报文的
- `TCP` 只能一对一通信，`UDP` 支持一对一，一对多，多对一，多对多
- `TCP` 可靠传输，使用流量控制和拥塞控制，`UDP` 不可靠
- `TCP` 头部开销大（20-60 字节），`UDP` 头部开销小（8 字节）

## 2.HTTP 状态码

- 1××：中间状态
  - `101` Switching Protocols
- 2××：成功
  - `200` OK
  - `204` No Content：不返回 body,埋点上报
  - `206` Partial Content
- 3xx：重定向
  - `301` 永久重定向
  - `302` 临时重定向 ；效果和 301 一样，只是语义不一样
  - `304` 缓存重定向 协商缓存验证
- 4xx：客户端错误
  - `400` Bad Request：通用的错误码
  - `401` unauthorized 未授权
  - `403` Forbidden
  - `404` Not Found
  - `405` Method Not Allowed
- 5xx：服务器错误
  - `500` Internal Server Error：通用的错误码
  - `502` Bad Gateway：网关/代理错误
  - `503` Service Unavailable 服务不可用

## 3.HTTP2 的特性

- 二进制帧
- 多路复用
- 头部压缩
- 服务器推送

**多路复用**：

- `HTTP/1.1`：同⼀时间⼀个 TCP 连接只能处理⼀个请求, 采⽤⼀问⼀答的形式, 上⼀个请求响应后才能处理下⼀个请求。由于浏览器最⼤ TCP 连接数的限制, 所以有了最⼤并发请求数的限制.
- `HTTP/2.0`：同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接⽽带来的延时和内存消耗。单个连接上可以并⾏交错的请求和响应，之间互不干扰。

为什么 `HTTP/1.1` 不能实现多路复⽤?

- `HTTP/2` 是基于⼆进制“帧”的协议，`HTTP/1.1` 是基于(报文)“⽂本分割”解析的协议。
- `HTTP1.1` 的报⽂结构中, 服务器需要不断的读⼊字节，直到遇到换⾏符, 或者说⼀个空⽩⾏. 处理顺序是串⾏的, ⼀个请求和⼀个响应需要通过⼀问⼀答的形式才能对应起来。
- `HTTP2.0` 中，有两个⾮常重要的概念，分别是`帧(frame)`和`流(stream）`。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
- `多路复⽤`，就是在⼀个 `TCP` 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极⼤的提⾼传输性能。

## 4.HTTPS 的原理

HTTPS 其实就是 HTTP+TLS 的传输方式，TLS 叫传输层安全，之前叫 SSL（安全套接层）。

因为 HTTP 属于明文传输，可以被截取到。那么就需要对传输报文进行加密，加密方式有两种：非对称和对称。对称就是同一个密钥进行加密解密，非对称就是有一组公私密钥，可以互相加解密。

那么 TLS 是怎么做的呢？

因为非对称加密的效率不高，对 HTTP 报文一般采用对称加密，然后通过非对称加密传输这个会话密钥。

比如客户端生成一个`会话密钥`通过一个`公钥`加密，服务端通过`私钥`解密获得会话密钥，就可以安全地传输报文了。

但是这个公钥不能安全地传输到客户端手里，即使加密也需要对应的密钥进行传输，现在的通过 `CA机构` 解决这个密钥的信任问题。

1. 服务端向 `CA机构`申请一个证书，这个证书，就是用 `CA机构的私钥` 加密过的 `网站的公钥`。
2. 然后客户端请求得到这个证书，通过预装在客户端的 `CA机构的公钥` 进行解密和验证签名，得到这个`网站的公钥`。
3. 简单的讲，客户端就可以生成一个`会话密钥`通过`网站的公钥`加密传输给服务端，服务端通过`网站的私钥`解密后就得到了这个`会话密钥`。

但是，真实情况不是这个简单流程(RSA)，有密钥交换算法，比如 ECDHE，在请求返回证书的过程，服务端和客户端会分别交互两个随机数，然后自个通过协商好的算法参数生成第三个随机数，再通过这个三个随机数生成会话密钥，这个密钥是不需要传输的，两边都知道，之后就可以加密传输了。

## 5.从输入 URL 到显示页面

- 浏览器处理 URL
  - 浏览器进程
- 网络进程 发起请求
  - 检查缓存
  - DNS 查找
  - HTTP(S) / TCP 连接
- 响应请求，渲染进程渲染页面
- **关键渲染路径**

## 6.DNS 解析

**DNS（Domain Name System，域名系统）是一个将域名和 IP 地址相互映射的分布式服务**
缓存：浏览器-操作系统-路由器-本地域名服务

1. 客户端发送请求给本地域名服务器，如果没有继续（递归）
2. 本地域名服务器，向**根域名服务器**，返回**顶级域名服务器**地址，然后请求拿到**权威域名服务器**，最后请求拿到 IP 返回给客户端（迭代）

一般我们向本地 DNS 服务器发送请求的方式就是**递归查询**，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是**迭代查询**的过程，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。

## 7.长连接/长轮询/短轮询/websocket

- 长连接：`Connection：keep-alive`

- 长轮询：服务端将请求挂起一定的时间再返回（微信二维码）

- 短轮询：客户端每隔一段时间发送请求

- websocket：全双工的协议，可以相互收发消息。

- EventSource：server 到 client，支持文本

## 8.CSRF

**csrf：跨站请求伪造(Cross—Site Request Forgery)**
攻击者利用 HTTP 请求会自动携带 cookie 的特定，利用用户的登陆状态发送恶意请求。
方法：自动发起 get/post 请求；诱导点击

CSRF 的过程：

- 用户登录了 `a.com` ，有了 cookie
- 黑客引诱用户访问 `b.com` 网页，偷偷让用户访问了 `a.com/api/xxx`（干某件事）
- `a.com` api 接口收到请求 cookie ，误以为是真实用户的请求，就受理了

**防御**：

- CSRF token 验证
- HTTP 请求头的 referer 字段（可以伪造），Origin(不含具体 url)
- SameSite 限制 Cookie 在跨站请求时不会被发送
  - Strict，必须是相同站点
  - Lax 宽松，允许部分类型，比如 a 链接
  - None 不限制

## 9.XSS

**XSS：跨站脚本(Cross Site Scripting)**

- **存储型**：将恶意代码存在服务器，请求含有恶意代码的页面。
- **反射型**：构建含有恶意代码的 url，服务器不存储，后端直接返回到页面。
- **DOM 型**：前端解析恶意代码执行，相比前两者，属于前端的漏洞。

**防御**：

- 本质是防止恶意脚本的注入
- 存储型和反射性：改成纯前端渲染， 对输入内容进行转义和过滤
- DOM 型：谨慎  innerHTML/ v-html ，字符串做代码执行的 eval,Function
- CSP 内容安全策略 Content-Security-Policy，白名单告诉浏览器认可的资源来源，http 响应头/meta
- 很多 XSS 盗取是 cookie 的，可以设置 Cookie 的 HttpOnly

## 10.前端鉴权方案有哪些

概念：鉴权（`Authentication`）：验证用户是否拥有访问系统的权利

常见的鉴权方式有以下几种方式：

1. `基本认证方案` 不安全，密码容易泄露
2. `session-cookie` session 需要存储， 依赖 cookie ，不安全：CSRF
3. `token` 前端存储 token，避免 CSRF，为了减少 token 被盗风险，缩短有效期，使用`Access Token`和`Refresh Token`(用于获取前者,时效长)
4. `JWT` token 验证服务端需要查询用户信息鉴权，JWT 的 Payload 负载中存储常用信息，服务端不存储状态，一旦签发无法废除
   JWT 由三部分组成： Header 头部、 Payload 负载 和 Signature 签名, 对这个 JSON 对象加密，
5. `SSO`
   - 同域：设置 Cookie 的 Domain 为 .baidu.com
   - 不同域：SSO.com 返回 token 验证 token 跳转
6. `OAuth2.0` 略

> - [一文教你搞定所有前端鉴权与后端鉴权方案，让你不再迷惘](https://juejin.cn/post/7129298214959710244#heading-26)
> - [前端鉴权的兄弟们：cookie、session、token、jwt、单点登录](https://juejin.cn/post/6898630134530752520)

## 11.http 头部有哪些

- 基础

  - `Accept` | `Content-Type` 内容类型
  - `Accept-Encoding` | `Content-Encoding` 编码方式
  - `Connection:Keep-Alive` 长连接
  - `Host` 主机名
  - `User-Agent` 浏览器信息
  - `Referer` 来源页面

- Cookie：`Cookie` | `Set-Cookie`
- 缓存
- CORS

## 12.cookie 有哪些字段
